## Doc

Программа состоит из упорядоченного списка `statements` предложений `statement`, разделенных символом ";".

`Statement` бывают двух видов: 
- Введение нового идентификатора - создается новое имя, 
  доступное для использования в последующих `statement`. 
  Если имя уже определено, оно будет переопределено без возможности использования предыдущего значения.

- Вывод на экран - вычисляется выражение (`Expresion`), его результат выводится в поток вывода.

`Expresion` - основная синтаксическая категория языка, включает в себя все вычислимые и присваиваемые значения:
  ```
  smth := <expr>;
  
  print(<expr>);
  ```

`Expresion`-ы могут быть разных типов, включая:

- Number (число) `smth := 42;`
- String (строка) `smth := "42";`
- Set (множество) `smth := {1,2,3}; smth := {1..10};`, [Iterable]()
- EpsilonNFA (эпсилон-НКА) `smth := load "bzip";`, [Iterable]()

Бинарные операции, такие как '=' (равно), '<' (меньше), '<=' (меньше или равно), '>=' (больше или равно) и '>' (больше), могут быть применены 
только с `expresion` одного типа. Одна унарная операции `*`
применима только к `expresion` типа `EpsilonNFA`. В языке отсутствует тип bool, 
однако он неявно присутствует в фильтрующих лямбда-выражениях.

## Лямбда-выражение
Абстрагируется по идентификатору (он попадает в глобальную область видимости, возможны коллизии).
```
(map|filter) <expr> by <lambda>
<lambda> :: smth => <expr>;
```
В качестве `expr` могут быть только [Iterable]() типы. Вычисляется энергично.
Результат - `expresion` типа Set.

## Детали реализации
Все манипуляции с выражениями выполняются через прокси-объект `Entity`, 
который скрывает от класса `InterpretVisitor` основную работу по манипуляции и проверке типов объектов `Expression`.

## Пример кода
```
g := load "bzip";

print(starts of g);
print(labels of g);

g := set start {1} to g;

print(map {1..10} by x => x ++ 5);
g := set start {1} to load "bzip"; 
print(starts of g);
```

